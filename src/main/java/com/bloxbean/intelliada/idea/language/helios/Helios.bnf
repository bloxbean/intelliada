{
  parserClass="com.bloxbean.intelliada.idea.language.helios.parser.HeliosParser"
  parserUtilClass="com.bloxbean.intelliada.idea.language.helios.psi.impl.HeliosParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Helios"
  psiImplClassSuffix="Impl"
  psiPackage="com.bloxbean.intelliada.idea.language.helios.psi"
  psiImplPackage="com.bloxbean.intelliada.idea.language.helios.psi.impl"

  elementTypeHolderClass="com.bloxbean.intelliada.idea.language.helios.psi.HeliosTypes"
  elementTypeClass="com.bloxbean.intelliada.idea.language.helios.psi.HeliosElementType"
  tokenTypeClass="com.bloxbean.intelliada.idea.language.helios.psi.HeliosTokenType"

  psiImplUtilClass="com.bloxbean.intelliada.idea.language.helios.psi.impl.HeliosPsiImplUtil"

  tokens = [
      NL = 'regexp:\r\n'
      EOF = 'regexp:\Z'
      SPACE='regexp:\s+'

    program_types_code="regexp:(test|minting_policy|validator)"

    line_comment='regexp://.*\n'
    block_comment='regexp:/\*(.|\n)*\*/'
    i_literal='regexp:[0-9]+ | 0b[0-1]+ | 0o[0-7]+ | 0x[0-9a-f]+'
    b_arrayliteral = 'regexp:# /[0-9a-f]*/'

//    s_literal = 'regexp: \\ | \n | \t | \" | [^\\]'
    s_literalchar = "regexp:('\\' | '\n' | '\t' | '\"' | [^\\])"
    t_word = 'regexp:[a-zA-Z_][0-9a-zA-Z_]*'

  ]
}

Program ::= ProgramType (Statement)*

//ProgramType ::= ('test' | 'minting_policy' | 'validator') Word
ProgramType ::= program_types_code Word

Statement ::= ConstStatement
                | StructStatement
                | FuncStatement
                | EnumStatement

//Comment ::= 'regexp://.*\n' | 'regexp:/\*(.*|\n)\*/'
Comment ::= line_comment | block_comment

StructStatement ::= 'struct' Word '{' DataDefinition [ImplDefinition] '}'

DataDefinition ::= DataField (DataField)*

DataField ::= NameTypePair

NameTypePair ::= Word ':' TypeExpr

EnumStatement ::= 'enum' Identifier '{' EnumMember (EnumMember)* [ImplDefinition] '}'

EnumMember ::= Word ['{' DataDefinition '}']

ImplDefinition ::= ImplMember (ImplMember)*

ImplMember ::= ConstStatement | FuncStatement

ConstStatement ::= 'const' Identifier [':' TypeExpr] '=' ValueExpr

FuncStatement ::= 'func' Identifier '(' [FuncArg (',' FuncArg)*] ')' '->' TypeExpr '{' ValueExpr '}' {pin=3}
//FuncStatement ::= FUNC Identifier '(' [FuncArg (',' FuncArg)*] ')' '->' TypeExpr '{' ValueExpr '}'

FuncArg ::= NameTypePair

TypeExpr ::= NonFuncTypeExpr | FuncTypeExpr

NonFuncTypeExpr ::= TypeRefExpr | TypePathExpr | ListTypeExpr | MapTypeExpr | OptionTypeExpr

FuncTypeExpr ::= '(' [TypeExpr (',' TypeExpr)*] ')' '->' TypeExpr

TypeRefExpr ::= Identifier

TypePathExpr ::= NonFuncTypeExpr '::' Word

ListTypeExpr ::= '[' ']' NonFuncTypeExpr

MapTypeExpr ::= 'Map' '[' NonFuncTypeExpr ']' NonFuncTypeExpr

OptionTypeExpr ::= 'Option' '[' NonFuncTypeExpr ']'

//ValueExpr ::= AssignExpr | PrintExpr | LiteralExpr | ValueRefExpr | ValuePathExpr | UnaryExpr | BinaryExpr | ParensExpr | CallExpr | MemberExpr | IfElseExpr | SwitchExpr
ValueExpr ::= BinaryExpr
                | AssignExpr
                | PrintExpr
                | UnaryExpr
                | ParensExpr
                | CallExpr
                | MemberExpr
                | IfElseExpr
                | SwitchExpr
                | ValueRefExpr
                | ValuePathExpr
                | LiteralExpr

LiteralExpr ::= PrimitiveLiteralExpr
                | StructLiteralExpr
                | ListLiteralExpr
                | FuncLiteralExpr

PrimitiveLiteralExpr ::= PrimitiveLiteral

PrimitiveLiteral ::= IntLiteral
                | BoolLiteral
                | StringLiteral
                | ByteArrayLiteral

StructLiteralExpr ::= (TypePathExpr | TypeRefExpr) ['{' StructLiteralField (',' StructLiteralField)* '}']

StructLiteralField ::= [Word ':'] ValueExpr

FuncLiteralExpr ::= '(' [FuncArg (',' FuncArc)*] ')' '->' TypeExpr '{' ValueExpr '}'

//IntLiteral ::= 'regexp:[0-9]+' | 'regexp:0b[0-1]+' | 'regexp:0o[0-7]+' | 'regexp:0x[0-9a-f]+'
IntLiteral ::= i_literal

BoolLiteral ::= 'true' | 'false'

StringLiteral ::= '"' StringLiteralChar* '"';

//StringLiteralChar ::= '\\' | '\n' | '\t' | '\"' | 'regexp:[^\\]' //TODO
StringLiteralChar ::= s_literalchar

//ByteArrayLiteral ::= '#' 'regexp:[0-9a-f]*'
ByteArrayLiteral ::= b_arrayliteral

BinaryExpr ::= ValueExpr BinaryOp ValueExpr {extends=ValueExpr}

ConditionalExpr ::= ValueExpr ConditionalOp ValueExpr {extends=ValueExpr}

//BinaryOp ::= '+' | '-' | '*' | '/' | '%' | '==' | '!=' | '<' | '>' | '<=' | '>=' | '||' | '&&'
BinaryOp ::= '+' | '-' | '*' | '/' | '%' | ConditionalOp
ConditionalOp ::= '==' | '!=' | '<' | '>' | '<=' | '>=' | '||' | '&&'

UnaryExpr ::= UnaryOp ValueExpr

UnaryOp ::= '-' | '+' | '!'

AssignExpr ::= Identifier [':' TypeExpr] '=' ValueExpr ';' ValueExpr

PrintExpr ::= 'print' '(' ValueExpr ')' ';' ValueExpr

//IfElseExpr ::= 'if' '(' ValueExpr ')' '{' ValueExpr '}' ('else' 'if' '(' ValueExpr ')' '{' ValueExpr '}')* 'else' '{' ValueExpr '}' {pin=2}

IfElseExpr ::= 'if' '(' ConditionalExpr ')' '{' ValueExpr '}' ('else' 'if' '(' ConditionalExpr ')' '{' ValueExpr '}')* 'else' '{' ValueExpr '}' {pin=2}


SwitchExpr ::= ValueExpr '.' 'switch' '{' SwitchCase (',' SwitchCase)* [SwitchDefault] '}' {extends=ValueExpr}

SwitchCase ::= (Word | (Identifier ':' Word)) '=>' (ValueExpr | ('{' ValueExpr '}'))

SwitchDefault ::= 'else' '=>' (ValueExpr | ('{' ValueExpr '}'))

CallExpr ::= ValueExpr '(' [ValueExpr (',' ValueExpr)*] ')'; {extends=ValueExpr}

MemberExpr ::= ValueExpr '.' Word {extends=ValueExpr}

ParensExpr ::= '(' ValueExpr ')'

ValuePathExpr ::= NonFuncTypeExpr '::' Word

ValueRefExpr ::= Identifier

Identifier ::= Word

//Word ::= 'regexp:[a-zA-Z_][0-9a-zA-Z_]*'
Word ::= t_word

