{
  parserClass="com.bloxbean.intelliada.idea.language.helios.parser.HeliosParser"
  parserUtilClass="com.bloxbean.intelliada.idea.language.helios.psi.impl.HeliosParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Helios"
  psiImplClassSuffix="Impl"
  psiPackage="com.bloxbean.intelliada.idea.language.helios.psi"
  psiImplPackage="com.bloxbean.intelliada.idea.language.helios.psi.impl"

  elementTypeHolderClass="com.bloxbean.intelliada.idea.language.helios.psi.HeliosTypes"
  elementTypeClass="com.bloxbean.intelliada.idea.language.helios.psi.HeliosElementType"
  tokenTypeClass="com.bloxbean.intelliada.idea.language.helios.psi.HeliosTokenType"

  psiImplUtilClass="com.bloxbean.intelliada.idea.language.helios.psi.impl.HeliosPsiImplUtil"

  extends(".*Expr")=ValueExpr
  tokens = [
      NL = 'regexp:\r\n'
      EOF = 'regexp:\Z'
      SPACE='regexp:\s+'

      STRUCT='struct'
      IF='if'
      ELSE='else'
      FUNC='func'
      OPTION = 'Option'
      SWITCH = 'switch'

    program_types_code="regexp:(testing|minting|spending|staking|module)"

    line_comment='regexp://.*\n'
    block_comment='regexp:/\*(.|\n)*\*/'
    i_literal='regexp:[0-9]+ | 0b[0-1]+ | 0o[0-7]+ | 0x[0-9a-f]+'
    b_arrayliteral = 'regexp:# /[0-9a-f]*/'

//    s_literal = 'regexp: \\ | \n | \t | \" | [^\\]'
    //s_literalchar = "regexp:('\\' | '\n' | '\t' | '\"' | [^\\])"
    t_word = 'regexp:[a-zA-Z_][0-9a-zA-Z_]*'

  ]
}

Program ::= ProgramType Statement (Statement)*

private UntilSemicolonRecover ::= !(';')
private UntilBraceRecover ::= !('}')

//ProgramType ::= ('test' | 'minting_policy' | 'validator') Word
ProgramType ::= program_types_code Word

Statement ::= (ImportStatement | ConstStatement | StructStatement | FuncStatement | EnumStatement)
//Statement ::= ConstStatement | StructStatement | FuncStatement | EnumStatement
private statement_recover ::= !(  "}" | "\r\n")

Comment ::= 'regexp://.*\n' | 'regexp:/\*(.*|\n)\*/'

ImportStatement ::= 'import' '{' ImportField (',' ImportField)* '}' 'from' ModuleName

ModuleName ::= Word

ImportField ::= Word ['as' Word]

StructStatement ::= STRUCT Word '{' DataDefinition [ImplDefinition] '}' {pin=3 recoverWhile=statement_recover}

DataDefinition ::= DataField (DataField)*

DataField ::= NameTypePair

NameTypePair ::= Word ':' TypeExpr

EnumStatement ::= 'enum' Identifier '{' EnumMember (EnumMember)* [ImplDefinition] '}'

EnumMember ::= Word ['{' DataDefinition '}']

ImplDefinition ::= ImplMember (ImplMember)*

ImplMember ::= ConstStatement | FuncStatement

ConstStatement ::= 'const' Identifier [':' TypeExpr] '=' ValueExpr

FuncStatement ::= FUNC Identifier '(' [('self' | FuncArg) (',' FuncArg)*] ')' '->' TypeExpr '{' ValueExpr '}'

FuncArg ::= NameTypePair

TypeExpr ::= NonFuncTypeExpr | FuncTypeExpr

NonFuncTypeExpr ::= TypeRefExpr | TypePathExpr | ListTypeExpr | MapTypeExpr | OptionTypeExpr

FuncTypeExpr ::= '(' [TypeExpr (',' TypeExpr)*] ')' '->' TypeExpr

TypeRefExpr ::= Identifier

TypePathExpr ::= NonFuncTypeExpr '::' Word

ListTypeExpr ::= '[' ']' NonFuncTypeExpr

MapTypeExpr ::= 'Map' '[' NonFuncTypeExpr ']' NonFuncTypeExpr

OptionTypeExpr ::= OPTION '[' NonFuncTypeExpr ']'

//ValueExpr ::= AssignExpr
//                  | PrintExpr
//                  | LiteralExpr
//                  | ValueRefExpr
//                  | ValuePathExpr
//                  | UnaryExpr
//                  | BinaryExpr
//                  | ParensExpr
//                  | CallExpr
//                  | MemberExpr
//                  | IfElseExpr
//                  | SwitchExpr

//VARIABLE ::=Identifier
//METHOD_NAME ::=Identifier
private MethodExpr ::= ValueExpr '.' CallExpr //TODO -- Check if it's required

ValueExpr ::= BinaryExpr
                | AssignExpr
                | PrintExpr
                | UnaryExpr
                | ParensExpr
                | CallExpr
                | MemberExpr
                | IfElseExpr
                | SwitchExpr
                | ValueRefExpr
                | ValuePathExpr
                | LiteralExpr


LiteralExpr ::= PrimitiveLiteralExpr | StructLiteralExpr | ListLiteralExpr | MapLiteralExpr | FuncLiteralExpr

PrimitiveLiteralExpr ::= PrimitiveLiteral

PrimitiveLiteral ::= IntLiteral | BoolLiteral | StringLiteral | ByteArrayLiteral

StructLiteralExpr ::= (TypePathExpr | TypeRefExpr) ['{' StructLiteralField (',' StructLiteralField)* '}']

StructLiteralField ::= [Word ':'] ValueExpr

ListLiteralExpr ::= '[]' TypeExpr '{' [ValueExpr] (',' ValueExpr)* '}'

MapLiteralExpr ::= 'Map' '[' TypeExpr ']' TypeExpr '{' [ValueExpr ':' ValueExpr] (',' ValueExpr ':' ValueExpr)* '}'

FuncLiteralExpr ::= '(' [FuncArg (',' FuncArc)*] ')' '->' TypeExpr '{' ValueExpr '}'

IntLiteral ::= 'regexp:[0-9]+' | 'regexp:0b[0-1]+' | 'regexp:0o[0-7]+' | 'regexp:0x[0-9a-f]+'

BoolLiteral ::= 'true' | 'false'

StringLiteral ::= '"' StringLiteralChar* '"';

//original StringLiteralChar ::= '\' | '\n' | '\t' | '"' | 'regexp:[^]'
StringLiteralChar ::= '\\' | '\n' | '\t' | '\"' | 'regexp:[^\\]'

ByteArrayLiteral ::= '#' 'regexp:[0-9a-f]*'

BinaryExpr ::= ValueExpr BinaryOp ValueExpr

BinaryOp ::= '+' | '-' | '*' | '/' | '%' | '==' | '!=' | '<' | '>' | '<=' | '>=' | '||' | '&&'

UnaryExpr ::= UnaryOp ValueExpr

UnaryOp ::= '-' | '+' | '!'

AssignExpr ::= Identifier [':' TypeExpr] '=' ValueExpr ';' ValueExpr

PrintExpr ::= 'print' '(' ValueExpr ')' ';' ValueExpr

IfElseExpr ::= IF '(' ValueExpr ')' '{' ValueExpr '}' (ELSE IF '(' ValueExpr ')' '{' ValueExpr '}')* ELSE '{' ValueExpr '}'


SwitchExpr ::= ValueExpr '.' SWITCH '{' SwitchCase (',' SwitchCase)* [SwitchDefault] '}'

SwitchCase ::= (Word | (Identifier ':' Word)) '=>' (ValueExpr | ('{' ValueExpr '}'))

SwitchDefault ::= ELSE '=>' (ValueExpr | ('{' ValueExpr '}'))

CallExpr ::= ValueExpr '(' [ValueExpr (',' ValueExpr)*] ')';

MemberExpr ::= ValueExpr '.' Word

ParensExpr ::= '(' ValueExpr ')'

ValuePathExpr ::= NonFuncTypeExpr '::' Word

ValueRefExpr ::= Identifier

Identifier ::= Word

//Word ::= 'regexp:[a-zA-Z_][0-9a-zA-Z_]*'
Word ::= t_word

